<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/converter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/converter.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import charMapping from './charMapping.js';

const CHAR_TO_NIBBLE_MAP = (() => {
	const builder = charMapping.createBuilder();
	builder.addRange('0', '9', 0);
	builder.addRange('a', 'f', 10);
	builder.addRange('A', 'F', 10);
	return builder.map;
})();

const CHAR_TO_DIGIT_MAP = (() => {
	const builder = charMapping.createBuilder();
	builder.addRange('0', '9', 0);
	return builder.map;
})();

const NIBBLE_TO_CHAR_MAP = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];

const SIGNEDNESS_AND_SIZE_TO_ARRAY_TYPE_MAPPING = {
	false: {
		1: Uint8Array,
		2: Uint16Array,
		4: Uint32Array,
		8: BigUint64Array
	},
	true: {
		1: Int8Array,
		2: Int16Array,
		4: Int32Array,
		8: BigInt64Array
	}
};

const tryParseByte = (char1, char2) => {
	const nibble1 = CHAR_TO_NIBBLE_MAP[char1];
	const nibble2 = CHAR_TO_NIBBLE_MAP[char2];
	return undefined === nibble1 || undefined === nibble2
		? undefined
		: (nibble1 &lt;&lt; 4) | nibble2;
};

/**
 * Decodes two hex characters into a byte.
 * @param {string} char1 First hex digit.
 * @param {string} char2 Second hex digit.
 * @returns {number} Decoded byte.
 */
const toByte = (char1, char2) => {
	const byte = tryParseByte(char1, char2);
	if (undefined === byte)
		throw Error(`unrecognized hex char '${char1}${char2}'`);

	return byte;
};

/**
 * Determines whether or not a string is a hex string.
 * @param {string} input String to test.
 * @returns {boolean} \c true if the input is a hex string, \c false otherwise.
 */
const isHexString = input => {
	if (0 !== input.length % 2)
		return false;

	for (let i = 0; i &lt; input.length; i += 2) {
		if (undefined === tryParseByte(input[i], input[i + 1]))
			return false;
	}

	return true;
};

/**
 * Converts a hex string to a uint8 array.
 * @param {string} input Hex encoded string.
 * @returns {Uint8Array} Uint8 array corresponding to the input.
 */
const hexToUint8 = input => {
	if (0 !== input.length % 2)
		throw Error(`hex string has unexpected size '${input.length}'`);

	const output = new Uint8Array(input.length / 2);
	for (let i = 0; i &lt; input.length; i += 2)
		output[i / 2] = toByte(input[i], input[i + 1]);

	return output;
};

/**
 * Converts a uint8 array to a hex string.
 * @param {Uint8Array} input Uint8 array.
 * @returns {string} Hex encoded string corresponding to the input.
 */
const uint8ToHex = input => {
	let s = '';
	input.forEach(byte => {
		s += NIBBLE_TO_CHAR_MAP[byte >> 4];
		s += NIBBLE_TO_CHAR_MAP[byte &amp; 0x0F];
	});

	return s;
};

/**
 * Tries to parse a string representing an unsigned integer.
 * @param {string} str String to parse.
 * @returns {number|undefined} Number represented by the input or undefined.
 */
const tryParseUint = str => {
	if ('0' === str)
		return 0;

	let value = 0;
	for (let i = 0; i &lt; str.length; ++i) {
		const char = str[i];
		const digit = CHAR_TO_DIGIT_MAP[char];
		if (undefined === digit || (0 === value &amp;&amp; 0 === digit))
			return undefined;

		value *= 10;
		value += digit;

		if (value > Number.MAX_SAFE_INTEGER)
			return undefined;
	}

	return value;
};

/**
 * Converts aligned bytes to little-endian number.
 * @param {Uint8Array} input Uint8 array.
 * @param {number} size Number of bytes.
 * @param {boolean} isSigned \c true if number should be treated as signed.
 * @returns {number} Value corresponding to the input.
 */
const bytesToInt = (input, size, isSigned = false) => {
	const DataType = SIGNEDNESS_AND_SIZE_TO_ARRAY_TYPE_MAPPING[isSigned][size];
	if (!DataType || 8 &lt;= size)
		throw Error(`unsupported int size ${size}`);

	return new DataType(input.buffer, input.byteOffset, 1)[0];
};

/**
 * Converts aligned bytes to little-endian number.
 * @param {Uint8Array} input Uint8 array.
 * @param {number} size Number of bytes.
 * @param {boolean} isSigned \c true if number should be treated as signed.
 * @returns {bigint} Value corresponding to the input.
 */
const bytesToBigInt = (input, size, isSigned = false) => {
	const DataType = SIGNEDNESS_AND_SIZE_TO_ARRAY_TYPE_MAPPING[isSigned][size];
	if (!DataType || 8 > size)
		throw Error(`unsupported int size ${size}`);

	return new DataType(input.buffer, input.byteOffset, 1)[0];
};

const bytesToIntUnalignedInternal = (input, size, isSigned, createMappingFromView) => {
	const view = new DataView(input.buffer, input.byteOffset);
	const mapping = createMappingFromView(view);

	const reader = mapping[isSigned][size];
	if (!reader)
		throw Error(`unsupported int size ${size}`);

	return reader.call(view, 0, true);
};

/**
 * Converts bytes to little-endian number.
 * @param {Uint8Array} input Uint8 array.
 * @param {number} size Number of bytes.
 * @param {boolean} isSigned \c true if number should be treated as signed.
 * @returns {number} Value corresponding to the input.
 */
const bytesToIntUnaligned = (input, size, isSigned = false) => bytesToIntUnalignedInternal(input, size, isSigned, view => ({
	false: {
		1: view.getUint8,
		2: view.getUint16,
		4: view.getUint32
	},
	true: {
		1: view.getInt8,
		2: view.getInt16,
		4: view.getInt32
	}
}));

/**
 * Converts bytes to little-endian number.
 * @param {Uint8Array} input Uint8 array.
 * @param {number} size Number of bytes.
 * @param {boolean} isSigned \c true if number should be treated as signed.
 * @returns {bigint} Value corresponding to the input.
 */
const bytesToBigIntUnaligned = (input, size, isSigned = false) => bytesToIntUnalignedInternal(input, size, isSigned, view => ({
	false: {
		8: view.getBigUint64
	},
	true: {
		8: view.getBigInt64
	}
}));

/**
 * Converts an integer to bytes.
 * @param {number|bigint} value Integer value.
 * @param {number} byteSize Number of output bytes.
 * @param {boolean} isSigned \c true if the value is signed.
 * @returns {Uint8Array} Byte representation of the integer.
 */
const intToBytes = (value, byteSize, isSigned = false) => {
	const DataType = SIGNEDNESS_AND_SIZE_TO_ARRAY_TYPE_MAPPING[isSigned][byteSize];
	const typedBuffer = new DataType([value]);
	return new Uint8Array(typedBuffer.buffer);
};

export {
	toByte,
	isHexString,
	hexToUint8,
	uint8ToHex,
	tryParseUint,
	bytesToInt,
	bytesToBigInt,
	bytesToIntUnaligned,
	bytesToBigIntUnaligned,
	intToBytes
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Address.html">Address</a></li><li><a href="AesCbcCipher.html">AesCbcCipher</a></li><li><a href="AesGcmCipher.html">AesGcmCipher</a></li><li><a href="Bip32.html">Bip32</a></li><li><a href="Bip32Node.html">Bip32Node</a></li><li><a href="BranchNode.html">BranchNode</a></li><li><a href="CharacterMapBuilder.html">CharacterMapBuilder</a></li><li><a href="Hash256.html">Hash256</a></li><li><a href="KeyPair.html">KeyPair</a></li><li><a href="LeafNode.html">LeafNode</a></li><li><a href="MerkleHashBuilder.html">MerkleHashBuilder</a></li><li><a href="Network.html">Network</a></li><li><a href="NetworkLocator.html">NetworkLocator</a></li><li><a href="NetworkTimestamp.html">NetworkTimestamp</a></li><li><a href="NetworkTimestampDatetimeConverter.html">NetworkTimestampDatetimeConverter</a></li><li><a href="PatriciaMerkleProofResult.html">PatriciaMerkleProofResult</a></li><li><a href="PrivateKey.html">PrivateKey</a></li><li><a href="PublicKey.html">PublicKey</a></li><li><a href="SharedKey256.html">SharedKey256</a></li><li><a href="Signature.html">Signature</a></li><li><a href="TreeNode.html">TreeNode</a></li><li><a href="Verifier.html">Verifier</a></li><li><a href="module.exports.html">exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addArrayParser">addArrayParser</a></li><li><a href="global.html#addEnumParser">addEnumParser</a></li><li><a href="global.html#addFlagsParser">addFlagsParser</a></li><li><a href="global.html#addPodParser">addPodParser</a></li><li><a href="global.html#addStructParser">addStructParser</a></li><li><a href="global.html#alignUp">alignUp</a></li><li><a href="global.html#attachSignature">attachSignature</a></li><li><a href="global.html#autodetect">autodetect</a></li><li><a href="global.html#bip32NodeToKeyPair">bip32NodeToKeyPair</a></li><li><a href="global.html#bip32Path">bip32Path</a></li><li><a href="global.html#bytesToBigInt">bytesToBigInt</a></li><li><a href="global.html#bytesToBigIntUnaligned">bytesToBigIntUnaligned</a></li><li><a href="global.html#bytesToInt">bytesToInt</a></li><li><a href="global.html#bytesToIntUnaligned">bytesToIntUnaligned</a></li><li><a href="global.html#copyTo">copyTo</a></li><li><a href="global.html#cosignTransaction">cosignTransaction</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#createEmbedded">createEmbedded</a></li><li><a href="global.html#createFromFactory">createFromFactory</a></li><li><a href="global.html#decode">decode</a></li><li><a href="global.html#deepCompare">deepCompare</a></li><li><a href="global.html#deriveSharedKey">deriveSharedKey</a></li><li><a href="global.html#deriveSharedKeyDeprecated">deriveSharedKeyDeprecated</a></li><li><a href="global.html#deriveSharedKeyFactory">deriveSharedKeyFactory</a></li><li><a href="global.html#deriveSharedSecretFactory">deriveSharedSecretFactory</a></li><li><a href="global.html#deserializePatriciaTreeNodes">deserializePatriciaTreeNodes</a></li><li><a href="global.html#encode">encode</a></li><li><a href="global.html#encodeDeprecated">encodeDeprecated</a></li><li><a href="global.html#encodePersistentHarvestingDelegation">encodePersistentHarvestingDelegation</a></li><li><a href="global.html#generate">generate</a></li><li><a href="global.html#generateMosaicAliasId">generateMosaicAliasId</a></li><li><a href="global.html#generateMosaicId">generateMosaicId</a></li><li><a href="global.html#generateNamespaceId">generateNamespaceId</a></li><li><a href="global.html#generateNamespacePath">generateNamespacePath</a></li><li><a href="global.html#hashEmbeddedTransactions">hashEmbeddedTransactions</a></li><li><a href="global.html#hashTransaction">hashTransaction</a></li><li><a href="global.html#hexToUint8">hexToUint8</a></li><li><a href="global.html#intToBytes">intToBytes</a></li><li><a href="global.html#isHexString">isHexString</a></li><li><a href="global.html#isValidNamespaceName">isValidNamespaceName</a></li><li><a href="global.html#lookupTransactionName">lookupTransactionName</a></li><li><a href="global.html#lookupValue">lookupValue</a></li><li><a href="global.html#merklePath%255Bundefined%255D">merklePath[undefined]</a></li><li><a href="global.html#metadataUpdateValue">metadataUpdateValue</a></li><li><a href="global.html#proveMerkle">proveMerkle</a></li><li><a href="global.html#provePatriciaMerkle">provePatriciaMerkle</a></li><li><a href="global.html#publicKey">publicKey</a></li><li><a href="global.html#readArray">readArray</a></li><li><a href="global.html#readArrayCount">readArrayCount</a></li><li><a href="global.html#readVariableSizeElements">readVariableSizeElements</a></li><li><a href="global.html#ripemdKeccak256">ripemdKeccak256</a></li><li><a href="global.html#ruleNames">ruleNames</a></li><li><a href="global.html#setTypeHints">setTypeHints</a></li><li><a href="global.html#shiftRight">shiftRight</a></li><li><a href="global.html#shrink">shrink</a></li><li><a href="global.html#signTransaction">signTransaction</a></li><li><a href="global.html#size">size</a></li><li><a href="global.html#toByte">toByte</a></li><li><a href="global.html#toNonVerifiableTransaction">toNonVerifiableTransaction</a></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#tryDecode">tryDecode</a></li><li><a href="global.html#tryDecodeDeprecated">tryDecodeDeprecated</a></li><li><a href="global.html#tryParseUint">tryParseUint</a></li><li><a href="global.html#uint8ToHex">uint8ToHex</a></li><li><a href="global.html#verifyTransaction">verifyTransaction</a></li><li><a href="global.html#window">window</a></li><li><a href="global.html#write">write</a></li><li><a href="global.html#writeArray">writeArray</a></li><li><a href="global.html#writeArrayCount">writeArrayCount</a></li><li><a href="global.html#writeVariableSizeElements">writeVariableSizeElements</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Thu Feb 29 2024 23:58:00 GMT+0900 (Japan Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
