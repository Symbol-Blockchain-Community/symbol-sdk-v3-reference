<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: RuleBasedTransactionFactory.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: RuleBasedTransactionFactory.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import BaseValue from './BaseValue.js';
import ByteArray from './ByteArray.js';
import TransactionDescriptorProcessor from './TransactionDescriptorProcessor.js';

const buildEnumStringToValueMap = EnumClass => new Map(Object.getOwnPropertyNames(EnumClass)
	.filter(name => name.toUpperCase() === name)
	.map(name => [name.toLowerCase(), EnumClass[name]]));

const nameToEnumValue = (mapping, enumType, enumValueName) => {
	if (!mapping.has(enumValueName))
		throw RangeError(`unknown value ${enumValueName} for type ${enumType}`);

	return mapping.get(enumValueName);
};

const buildTypeHintsMap = structValue => {
	/** @type {{[key: string]: string}} */
	const typeHints = {};
	const rawTypeHints = structValue.constructor.TYPE_HINTS || {};
	Object.getOwnPropertyNames(rawTypeHints).forEach(key => {
		const hint = rawTypeHints[key];
		let ruleName;
		if (0 === hint.indexOf('array['))
			ruleName = hint;
		else if (0 === hint.indexOf('enum:'))
			ruleName = hint.substring('enum:'.length);
		else if (0 === hint.indexOf('pod:'))
			ruleName = hint.substring('pod:'.length);
		else if (0 === hint.indexOf('struct:'))
			ruleName = hint;

		if (ruleName)
			typeHints[key] = ruleName;
	});

	return typeHints;
};

const typeConverterFactory = (module, customTypeConverter, value) => {
	if (customTypeConverter &amp;&amp; customTypeConverter(value))
		return customTypeConverter(value);

	if (value instanceof ByteArray) {
		/** @type object */
		const ByteArrayClass = value.constructor;

		if (ByteArrayClass.NAME in module)
			return new module[ByteArrayClass.NAME](value.bytes);

		return new ByteArrayClass(value.bytes);
	}

	return value;
};

const autoEncodeStrings = entity => {
	Object.getOwnPropertyNames(entity).forEach(key => {
		const value = entity[key];
		if ('string' === typeof (value))
			entity[key] = new TextEncoder().encode(value);
	});
};

/**
 * Rule based transaction factory.
 * @note This class is not intended to be used directly.
 */
export default class RuleBasedTransactionFactory {
	/**
	 * Creates a rule based transaction factory for use with catbuffer generated code.
	 * @param {object} module Catbuffer generated module.
	 * @param {function|undefined} typeConverter Type converter.
	 * @param {Map&lt;string, function>|undefined} typeRuleOverrides Type rule overrides.
	 */
	constructor(module, typeConverter = undefined, typeRuleOverrides = undefined) {
		/**
		 * @private
		 */
		this._module = module;

		/**
		 * Tries to coerce a value to a more appropriate type.
		 * @param {object} value Original value.
		 * @returns {object} Type converted value.
		 * @private
		 */
		this._typeConverter = value => typeConverterFactory(this._module, typeConverter, value);

		/**
		 * @private
		 */
		this._typeRuleOverrides = typeRuleOverrides || new Map();

		/**
		 * Map of rule names to transform functions.
		 * @type Map&lt;string, function>
		 */
		this.rules = new Map();
	}

	/**
	 * Looks up a class in the wrapped module.
	 * @param {string} name Class name.
	 * @returns {Constructable} Class type.
	 * @private
	 */
	_getModuleClass(name) {
		return this._module[name];
	}

	/**
	 * Creates wrapper for SDK POD types.
	 * @param {string} name Class name.
	 * @param {Constructable} PodClass Class type.
	 */
	addPodParser(name, PodClass) {
		if (this._typeRuleOverrides.has(PodClass)) {
			this.rules.set(name, this._typeRuleOverrides.get(PodClass));
			return;
		}

		this.rules.set(name, value => (value instanceof PodClass ? value : new PodClass(value)));
	}

	/**
	 * Creates flag type parser.
	 * @param {string} name Class name.
	 */
	addFlagsParser(name) {
		const FlagsClass = this._getModuleClass(name);
		const stringToEnum = buildEnumStringToValueMap(FlagsClass);

		this.rules.set(name, flags => {
			if ('string' === typeof (flags)) {
				const enumArray = flags.split(' ').map(flagName => nameToEnumValue(stringToEnum, name, flagName));
				return new FlagsClass(enumArray.map(flag => flag.value).reduce((x, y) => x | y));
			}

			if ('number' === typeof (flags) &amp;&amp; Number.isInteger(flags))
				return new FlagsClass(flags);

			return flags;
		});
	}

	/**
	 * Creates enum type parser.
	 * @param {string} name Class name.
	 */
	addEnumParser(name) {
		const EnumClass = this._getModuleClass(name);
		const stringToEnum = buildEnumStringToValueMap(EnumClass);

		this.rules.set(name, enumValue => {
			if ('string' === typeof (enumValue))
				return nameToEnumValue(stringToEnum, name, enumValue);

			if ('number' === typeof (enumValue) &amp;&amp; Number.isInteger(enumValue))
				return new EnumClass(enumValue);

			return enumValue;
		});
	}

	/**
	 * Creates struct parser (to allow nested parsing).
	 * @param {string} name Class name.
	 */
	addStructParser(name) {
		const StructClass = this._getModuleClass(name);

		this.rules.set(`struct:${name}`, structDescriptor => {
			const structProcessor = this._createProcessor(structDescriptor);
			const structValue = new StructClass();

			const allTypeHints = buildTypeHintsMap(structValue);
			structProcessor.setTypeHints(allTypeHints);

			structProcessor.copyTo(structValue);
			return structValue;
		});
	}

	/**
	 * Creates array type parser, based on some existing element type parser.
	 * @param {string} name Class name.
	 */
	addArrayParser(name) {
		const elementRule = this.rules.get(name);
		if (!elementRule)
			throw Error(`cannot create array type parser because element rule "${name}" is unknown`);

		const elementName = name.replace(/^struct:/, '');
		this.rules.set(`array[${elementName}]`, values => values.map(value => elementRule(value)));
	}

	/**
	 * Autodetects rules using reflection.
	 */
	autodetect() {
		Object.getOwnPropertyNames(this._module).forEach(key => {
			const cls = this._module[key];
			if (Object.prototype.isPrototypeOf.call(BaseValue.prototype, cls.prototype))
				this.addPodParser(key, cls);
		});
	}

	/**
	 * Creates an entity from a descriptor using a factory.
	 * @param {function} factory Factory function.
	 * @param {object} descriptor Entity descriptor.
	 * @returns {object} Newly created entity.
	 */
	createFromFactory(factory, descriptor) {
		const processor = this._createProcessor(descriptor);
		const entityType = processor.lookupValue('type');
		const entity = factory(entityType);

		const allTypeHints = buildTypeHintsMap(entity);
		processor.setTypeHints(allTypeHints);
		processor.copyTo(entity, ['type']);

		autoEncodeStrings(entity);
		return entity;
	}

	/**
	 * Creates a transaction descriptor processor around a descriptor.
	 * @param {object} descriptor Transaction descriptor.
	 * @returns {TransactionDescriptorProcessor} Transaction descriptor processor.
	 * @private
	 */
	_createProcessor(descriptor) {
		return new TransactionDescriptorProcessor(descriptor, this.rules, this._typeConverter);
	}
}

// region type declarations

/**
 * Constructable class type.
 * @class
 * @typedef {{new(...args: any[]): object}} Constructable
 */

// endregion
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Address.html">Address</a></li><li><a href="AesCbcCipher.html">AesCbcCipher</a></li><li><a href="AesGcmCipher.html">AesGcmCipher</a></li><li><a href="Bip32.html">Bip32</a></li><li><a href="Bip32Node.html">Bip32Node</a></li><li><a href="BranchNode.html">BranchNode</a></li><li><a href="CharacterMapBuilder.html">CharacterMapBuilder</a></li><li><a href="Hash256.html">Hash256</a></li><li><a href="KeyPair.html">KeyPair</a></li><li><a href="LeafNode.html">LeafNode</a></li><li><a href="MerkleHashBuilder.html">MerkleHashBuilder</a></li><li><a href="Network.html">Network</a></li><li><a href="NetworkLocator.html">NetworkLocator</a></li><li><a href="NetworkTimestamp.html">NetworkTimestamp</a></li><li><a href="NetworkTimestampDatetimeConverter.html">NetworkTimestampDatetimeConverter</a></li><li><a href="PatriciaMerkleProofResult.html">PatriciaMerkleProofResult</a></li><li><a href="PrivateKey.html">PrivateKey</a></li><li><a href="PublicKey.html">PublicKey</a></li><li><a href="SharedKey256.html">SharedKey256</a></li><li><a href="Signature.html">Signature</a></li><li><a href="TreeNode.html">TreeNode</a></li><li><a href="Verifier.html">Verifier</a></li><li><a href="module.exports.html">exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addArrayParser">addArrayParser</a></li><li><a href="global.html#addEnumParser">addEnumParser</a></li><li><a href="global.html#addFlagsParser">addFlagsParser</a></li><li><a href="global.html#addPodParser">addPodParser</a></li><li><a href="global.html#addStructParser">addStructParser</a></li><li><a href="global.html#alignUp">alignUp</a></li><li><a href="global.html#attachSignature">attachSignature</a></li><li><a href="global.html#autodetect">autodetect</a></li><li><a href="global.html#bip32NodeToKeyPair">bip32NodeToKeyPair</a></li><li><a href="global.html#bip32Path">bip32Path</a></li><li><a href="global.html#bytesToBigInt">bytesToBigInt</a></li><li><a href="global.html#bytesToBigIntUnaligned">bytesToBigIntUnaligned</a></li><li><a href="global.html#bytesToInt">bytesToInt</a></li><li><a href="global.html#bytesToIntUnaligned">bytesToIntUnaligned</a></li><li><a href="global.html#copyTo">copyTo</a></li><li><a href="global.html#cosignTransaction">cosignTransaction</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#createEmbedded">createEmbedded</a></li><li><a href="global.html#createFromFactory">createFromFactory</a></li><li><a href="global.html#decode">decode</a></li><li><a href="global.html#deepCompare">deepCompare</a></li><li><a href="global.html#deriveSharedKey">deriveSharedKey</a></li><li><a href="global.html#deriveSharedKeyDeprecated">deriveSharedKeyDeprecated</a></li><li><a href="global.html#deriveSharedKeyFactory">deriveSharedKeyFactory</a></li><li><a href="global.html#deriveSharedSecretFactory">deriveSharedSecretFactory</a></li><li><a href="global.html#deserializePatriciaTreeNodes">deserializePatriciaTreeNodes</a></li><li><a href="global.html#encode">encode</a></li><li><a href="global.html#encodeDeprecated">encodeDeprecated</a></li><li><a href="global.html#encodePersistentHarvestingDelegation">encodePersistentHarvestingDelegation</a></li><li><a href="global.html#generate">generate</a></li><li><a href="global.html#generateMosaicAliasId">generateMosaicAliasId</a></li><li><a href="global.html#generateMosaicId">generateMosaicId</a></li><li><a href="global.html#generateNamespaceId">generateNamespaceId</a></li><li><a href="global.html#generateNamespacePath">generateNamespacePath</a></li><li><a href="global.html#hashEmbeddedTransactions">hashEmbeddedTransactions</a></li><li><a href="global.html#hashTransaction">hashTransaction</a></li><li><a href="global.html#hexToUint8">hexToUint8</a></li><li><a href="global.html#intToBytes">intToBytes</a></li><li><a href="global.html#isHexString">isHexString</a></li><li><a href="global.html#isValidNamespaceName">isValidNamespaceName</a></li><li><a href="global.html#lookupTransactionName">lookupTransactionName</a></li><li><a href="global.html#lookupValue">lookupValue</a></li><li><a href="global.html#merklePath%255Bundefined%255D">merklePath[undefined]</a></li><li><a href="global.html#metadataUpdateValue">metadataUpdateValue</a></li><li><a href="global.html#proveMerkle">proveMerkle</a></li><li><a href="global.html#provePatriciaMerkle">provePatriciaMerkle</a></li><li><a href="global.html#publicKey">publicKey</a></li><li><a href="global.html#readArray">readArray</a></li><li><a href="global.html#readArrayCount">readArrayCount</a></li><li><a href="global.html#readVariableSizeElements">readVariableSizeElements</a></li><li><a href="global.html#ripemdKeccak256">ripemdKeccak256</a></li><li><a href="global.html#ruleNames">ruleNames</a></li><li><a href="global.html#setTypeHints">setTypeHints</a></li><li><a href="global.html#shiftRight">shiftRight</a></li><li><a href="global.html#shrink">shrink</a></li><li><a href="global.html#signTransaction">signTransaction</a></li><li><a href="global.html#size">size</a></li><li><a href="global.html#toByte">toByte</a></li><li><a href="global.html#toNonVerifiableTransaction">toNonVerifiableTransaction</a></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#tryDecode">tryDecode</a></li><li><a href="global.html#tryDecodeDeprecated">tryDecodeDeprecated</a></li><li><a href="global.html#tryParseUint">tryParseUint</a></li><li><a href="global.html#uint8ToHex">uint8ToHex</a></li><li><a href="global.html#verifyTransaction">verifyTransaction</a></li><li><a href="global.html#window">window</a></li><li><a href="global.html#write">write</a></li><li><a href="global.html#writeArray">writeArray</a></li><li><a href="global.html#writeArrayCount">writeArrayCount</a></li><li><a href="global.html#writeVariableSizeElements">writeVariableSizeElements</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Thu Feb 29 2024 23:58:00 GMT+0900 (Japan Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
